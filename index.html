<!DOCTYPE html>
<html>
<head>
  <title>Le pont</title>
  <meta charset="utf-8">
</head>

<link rel="stylesheet" type="text/css" href="srt.css">

<body id="body" onload="zoupage()">

  <div id="gcontainer">
    <div id="srtcontainer" class="posmid">
      <div id="srt">
        Bonjour
      </div>
      <div id="sacbouttons">
      </div>
    </div>

    <div id="imgcontainerBACK">
      <div id="imgcontainerFRONT">
      </div>
    </div>
  </div>
</body>
</html>

<script src="https://code.jquery.com/jquery-2.2.0.min.js"></script>

<script>

// TO DO
// balises pour afficher du texte ailleurs que dans SRT (checklist, rubrique fiction)
// implémenter vraiment le truc du plein écran

var compteur = 0
var interupt = false
var indeximg = 0
var alternance = false

var data = []

function loadJSON(callback) {   

  var xobj = new XMLHttpRequest();
  xobj.overrideMimeType("application/json");
  xobj.open('GET', 'libs/output.json', true); // Replace 'my_data' with the path to your file
  xobj.onreadystatechange = function () {
    if (xobj.readyState == 4 && xobj.status == "200") {
    // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode
    callback(xobj.responseText);
  }
};
xobj.send(null);  
}

//usage:
function zoupage() {

 loadJSON(function(response) {
  // Parse JSON string into object
  var actual_JSON = JSON.parse(response);

  for(i=0; i<actual_JSON.length; i++){
    data.push(actual_JSON[i])
  }
});
}

function next(){
  //TODO
  //attention dans le cas actuel il est impossible d'avoir la div de texte vide. il faudrait avoir une balise
  //action spécifique pour vider la div
  //solution envisagée :
  //au moment de parser data, il rajoute une balise #clear une ligne sur deux par exemple

  var currentData = data[compteur]
  var type = currentData["type"]
  var params = currentData["text"]

  while((data[compteur]["type"]!="text")||((data[compteur]["type"]=="text")&&(data[compteur]["text"]==""))){
      // tant que data[compteur] est une balise, ben continue à executer les instructions s'il te plaît
      action(type, params)
      if((data[compteur]["type"]!="text")||(data[compteur]["text"]=="")){
        // euh alors ça je sais pas pourquoi ça marche mais ça permet d'éviter des situations où, arrivé à un bookmark
        // il sautait deux lignes au lieu d'une
        compteur+=1;
        next();
      }
    }
    if((type=="text")&&(params!="")){
      document.getElementById("srt").innerHTML = params
      // pis si la balise c'est pas une action et pas une balise de texte vide, met a jour le texte
    }
  }


  function action(type, params){

    switch(type){

      case "addclass":
      addclass(params)
      break

      case "goto":
      gotobookmark(params[0])
      break

      case "btn":
    // BOUTTON
    // trigger pour faire apparaître les boutons
    // supprime les anciens bouttons
    commande = (params[0])

    params.shift()

    switch(commande){
      case "add":
      newBoutton(params)
      break;

      case "rm":
      removeBoutton(params)
      break;

      default:
      console.log("ERR invalid params '"+commande+"' must use rm or add for first params")
      break;
    }
    break;


    case "img":
    // IMAGE
    // trigger pour enclencher un fadeout styled
    if(alternance){
      changeImg(params)    
    }else{
      changeImg(params)
    }
    alternance =! alternance
    break;

    case "fullscreen":
    fullscreen();
    break;

  }

}
function addFiction(params){
  var ul = document.getElementById("elemfiction")
  var li = document.createElement("li")
  li.setAttribute("id", phrase)
  li.appendChild(document.createTextNode(phrase))
  ul.appendChild(li)
}

function removeFiction(params){
  var li = document.getElementById(phrase);
  if(li!=null){
    li.parentNode.removeChild(li);
  }else{
    console.log("ERR cannot find element '"+ phrase + "'")
  }
}

function changeImg(params){
  //bon being ça marche par contre pas de contrôle que les animations sont finies pour passer à la suite
  if (alternance) {
    $("#imgcontainerFRONT").css("background-image", "url(/img/"+params[0]);  
    $("#imgcontainerFRONT").css("opacity", "1");  
  }else{
    $("#imgcontainerBACK").css("background-image", "url(/img/"+params[0]);  
    $("#imgcontainerFRONT").css("opacity", "0");  
  }
  console.log(alternance)
  console.log(params[0])
}

function addclass(params){
  console.log("addclass, ", params[0], params[1])
  $("#"+params[0]).addClass(params[1])
}

function newBoutton(params){
  /* var buttonsname = params.match(/[^\s\d]\w+/g)
  var howmuch = buttonsname.length
  var anciensBouttons = $("#sacbouttons").empty();
  for(i=0; i<howmuch; i+=1){
    var newBoutton = $('<input type="button" value="'+ buttonsname[i] +'" onclick = "clicboutton(this)"/>');
    newBoutton.appendTo($("#sacbouttons"));
  }
  // ça c'était pour créer les bouttons en masse d'un coup pim un bouton / mot. 
  // c'était intéressant hein
  */
  interupt=true

  var nom = params[0]
  params.shift()
  console.log("heheheoho",params)
  var fonctions = []

  var howmany = params.length
  for(i=0; i<howmany; i++){
    var fonction = params[i]
    fonctionpropre = fonction.substr(1)
    fonctions.push(fonctionpropre)
    fonctionsconcat = fonctions.join(";")
  }

  var newBoutton = $('<input type="button" value="'+ nom +'" id="'+ nom +'" onclick = "' + fonctionsconcat + '">')
  newBoutton.appendTo($("#sacbouttons"))
}

function fullscreen(){
  var i = document.getElementById("gcontainer");
  if (i.requestFullscreen) {
    i.requestFullscreen();
  } else if (i.webkitRequestFullscreen) {
    i.webkitRequestFullscreen();
  } else if (i.mozRequestFullScreen) {
    i.mozRequestFullScreen();
  } else if (i.msRequestFullscreen) {
    i.msRequestFullscreen();
  }
}

function stop(onoff){
  if(onoff=="on") interupt=true
    if(onoff=="off") interupt=false
      console.log(interupt)
  // bon alors c'est bien sympa tout ça mais le problème
  // c'est que ça fire onclick (et c'est pas ça qu'on veut faire hein.)
}

function destroy(self){
  var element = document.getElementById(self)
  var parentid = element.parentNode.id
  $("#"+parentid).empty();
}

function gotobookmark(where){
  if(interupt==true) interupt=false
    howmuch = data.length
  for(i=0; i<howmuch; i++){
    if((data[i]["type"]=="bookmark")&&(data[i]["text"]==where)){
      //ça c'est la valeur de ton compteur mon ptit gars
      compteur = i
      next()
      console.log("gotobookmark, ", compteur)
      return
    }
  }
}

function gotonext(){
  compteur +=1
  next()
  interupt=false
  console.log("gotonext, ", compteur)
}

document.onkeydown = function(e) {

  e = e || window.event

  // KEYCODE 32 IS SPACEBAR
  // KEYCIODE 78 IS "n"

  if(e.keyCode =='32' && compteur <= data.length && interupt==false){
    compteur +=1
    next();
    console.log("keydown, ", compteur)
  }

}

</script>
